# CPU 스케줄링

#### 자원을 어떤 프로세스에 얼마나 할당하는지 정책을 만드는 것

## 왜 필요한가?

- 프로세스가 CPU를 점유하여 작업을 수행하는 도중 I/O 또는 Interrupt가 발생하면 일시적을 프로세스는 CPU를 사용하지 않게 되지만 계속 점유하고 있는 상태가 된다.
  -> 따라서 이런 상황을 줄여 CPU를 최대한 활용하여 시스템의 성능 개선을 꾀하기 위해서이다.

## 선점 스케줄링

- CPU가 어떤 프로세스에 의해 점유 중일 떄, 우선 순위가 높은 프로세스가 CPU를 차지할 수 있다.
- 우선 순위가 높은 프로세스를 빠르게 처리해야할 경우 유용하다.
- 선점이 일어날 경우, 오버헤드가 발생하며 처리시간을 예측하기 힘들다.

```
오버헤드 : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다.
```

### 선점 스케줄링 알고리즘 기법

##### 1. SRT(Shortest Remaining Time) 스케줄링

- 짧은 시간 순서대로 프로세스를 수행한다.
- 남은 처리 시간이 더 짧은 프로세스가 Ready 큐에 들어오면 그 프로세스가 바로 선점된다.
- 잦은 문맥교환이 일어나고 그에 따른 오버헤드가 커진다.

#### 2. 라운드 로빈(Round-Robin) 스케줄링

- 각 프로세스는 같은 크기의 CPU 시간을 할당 받고 선입선출에 의해 실행된다.
- 할당된 시간안에 처리를 다 하지 못하면 다음 프로세스가 CPU를 뺴앗고 뺴앗긴 프로세스는 준비 큐 맨 뒤로 간다.
- 할당 시간이 너무 크면 선입선출과 다를 바가 없어지고, 너무 작으면 오버헤드가 너무 커진다.

#### 3. 다단계 큐(Multilevel Queue) 스케줄링

- Ready 큐를 여러 개 사용하는 기법
- 각각의 큐는 자신의 스케줄링 알고리즘을 수행한다.
- 큐와 큐 사이에도 우선순위를 부여한다.

#### 4. 다단계 피드백 큐(Multilevel Feedback Queue) 스케줄링

- 다단계 큐와 비슷하나 프로세스들이 큐를 이동할 수 있다.

## 비선점 스케줄링

- 이미 할당된 자원을 다른 프로세스가 강탈할 수 없다.
- 응답시간의 예측이 편하며, 일괄처리 방식에 적합하다.
- 더 중요한 작업이 와도 먼저 처리될 수 없다.

### 비선점 스케줄링 알고리즘 기법

#### 1. FCFS (First Come First Served) 스케줄링

- 먼저 들어온 것이 먼저 처리되는 FIFO(First In First Out) 구조의 알고리즘이다.
- 작업 완료 시간을 예측하기 매우 용이하다.
- 덜 중요한 작업이 중요한 작업을 기다리게 할 수도 있다.

#### 2. SJF(Shortest Job First) 스케줄링

- 큐 안에 있는 프로세스 중 수행시간이 짧은 것을 먼저 수행한다.
- 가장 적은 평균 대기시간을 가진다.
- 실행 시간이 긴 프로세스의 경우 실행시간이 짧은 프로세스에게 우선순위가 자꾸 밀려 무한대기 상태가 발생할 수 있다.
  ( **starvation 현상 (=기아상태)** )

#### 3. HRN(Highest response ratio next) 스케줄링

- 긴 작업과 짧은 작업간의 지나친 불평등(SJF의 단점)을 어느정도 보완한 기법
- 우선순위 계산식을 이용하여 우선순위가 높은 프로세스에 자원 할당
  ![HRN](../../images/HRN.png "HRN")

#### 4. 우선순위(priority) 스케줄링

- 프로세스마다 우선순위를 부여하여 높은 우선순위를 가진 프로세스에게 먼저 자원을 할당
- 우선순위가 낮을 경우 기아상태가 일어날수 있다.
- SJF, HRN, SRT도 우선순위 스케줄링 알고리즘의 일종
- 위의 알고리즘들과 마찬가지로 starvation 문제와 공평성 문제가 있다.

#### 5. 기한부(Deadline) 스케줄링

- 작업을 명시된 시간이나 기한 내에 완료하도록 계획하는 방식
- timeout시 제거되거나 처음부터 다시 시작한다.
